lines(seq(2.5,3.625,length.out = 4),colMeans(tNodesA[,1:4]),col=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(tNodesB),col=2,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 4),colMeans(tNodesB),col=2,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 4),colMeans(tNodesA[,1:4]),col=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(tNodesB),col=2,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(tNodesC),col=3,pch=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(tNodesD),col=4,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,4,length.out = 4),colMeans(rmseNodesD),col=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesD),col=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 4),colMeans(tNodesD),col=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
plot(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesA[,1:4])),col=1,pch=19,xlab = 'minimum mesh angle', ylab='mean RMSE',ylim=c(min(colMeans(tNodesA)),max(colMeans(tNodesD))))
lines(seq(2.5,3.625,length.out = 4),colMeans(tNodesA[,1:4]),col=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
plot(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesA[,1:4])),col=1,pch=19,xlab = 'minimum mesh angle', ylab='mean RMSE',ylim=c(min(log(colMeans(tNodesA))),max(log(colMeans(tNodesD)))))
lines(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesA[,1:4])),col=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesB)),col=2,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesC)),col=3,pch=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesD)),col=4,pch=19,xlab = 'minimum mesh angle', ylab='mean RMSE')
plot(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesA[,1:4])),col=1,pch=19,xlab = 'minimum mesh angle', ylab='mean RMSE',ylim=c(min(log(colMeans(tNodesA))),max(log(colMeans(tNodesD)))))
lines(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesA[,1:4])),col=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 4),colMeans(tNodesB),col=2,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesD)),col=4,pch=19,xlab = 'minimum mesh angle', ylab='mean RMSE')
plot(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesA[,1:4])),col=1,pch=19,xlab = 'minimum mesh angle', ylab='mean RMSE',ylim=c(min(log(colMeans(tNodesA))),max(log(colMeans(tNodesD)))))
lines(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesA[,1:4])),col=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesB)),col=2,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesC)),col=3,pch=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesD)),col=4,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesD)),col=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
grid()
legend('bottomright',legend=c('no preconditioner', 'mass lumping',' lambda preconditioner', 'block preconditioner'), cex=0.62,col=1:4, pch=19)
load("~/iterations.RData")
plot(fem(sol_exact,FEMbasis))
image(FEM(sol_exact,FEMbasis))
nnodes
ang
load("~/data.RData")
plot(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesA[,1:4])),col=1,pch=19,xlab = 'log_10(number of nodes)', ylab='mean RMSE',ylim=c(min(log(colMeans(tNodesA))),max(log(colMeans(tNodesD)))))
lines(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesA[,1:4])),col=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesB)),col=2,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 4),colMeans(tNodesB),col=2,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesC)),col=3,pch=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 5)[1:4],colMeans(tNodesC),col=3,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesD)),col=4,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesD)),col=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
grid()
legend('bottomright',legend=c('no preconditioner', 'mass lumping',' lambda preconditioner', 'block preconditioner'), cex=0.62,col=1:4, pch=19)
plot(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesA[,1:4])),col=1,pch=19,xlab = 'log_10(number of nodes)', ylab='log time',ylim=c(min(log(colMeans(tNodesA))),max(log(colMeans(tNodesD)))))
lines(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesA[,1:4])),col=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesB)),col=2,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 4),colMeans(tNodesB),col=2,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesC)),col=3,pch=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 5)[1:4],colMeans(tNodesC),col=3,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesD)),col=4,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesD)),col=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
grid()
legend('bottomright',legend=c('no preconditioner', 'mass lumping',' lambda preconditioner', 'block preconditioner'), cex=0.62,col=1:4, pch=19)
plot(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesA[,1:4]),col=1,pch=19,xlab = 'log_10(number of nodes)', ylab='mean RMSE',ylim=c(min(log(colMeans(tNodesA))),max(log(colMeans(tNodesD)))))
plot(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesA[,1:4]),col=1,pch=19,xlab = 'log_10(number of nodes)', ylab='mean RMSE',ylim=c(min(colMeans(rmseNodesA)),max(colMeans(rmseNodesDB)))
)
plot(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesA[,1:4]),col=1,pch=19,xlab = 'log_10(number of nodes)', ylab='mean RMSE',ylim=c(min(colMeans(rmseNodesA)),max(colMeans(rmseNodesB))))
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesA[,1:4]),col=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesB),col=2,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
plot(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesA[,5:8]),col=1,pch=19,xlab = 'log_10(number of nodes)', ylab='mean RMSE',ylim=c(min(colMeans(rmseNodesA)),max(colMeans(rmseNodesB))))
points(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesB)[,1:4],col=2,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesB[,1:4]),col=2,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
plot(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesA[,1:4]),col=1,pch=19,xlab = 'log_10(number of nodes)', ylab='mean RMSE',ylim=c(min(colMeans(rmseNodesA)),max(colMeans(rmseNodesB))))
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesA[,1:4]),col=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesB[,1:4]),col=2,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesC),col=3,pch=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesB[,5:8]),col=2,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
plot(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesA[,5:8]),col=1,pch=19,xlab = 'log_10(number of nodes)', ylab='mean RMSE',ylim=c(min(colMeans(rmseNodesA)),max(colMeans(rmseNodesB))))
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesA[,5:8]),col=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesB[,5:8]),col=2,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesB),col=2,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesC),col=3,pch=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesD),col=4,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
grid()
legend('bottomright',legend=c('no preconditioner', 'mass lumping',' lambda preconditioner', 'block preconditioner'), cex=0.62,col=1:4, pch=19)
plot(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesA[,1:4])),col=1,pch=19,xlab = 'log_10(number of nodes)', ylab='log time',ylim=c(min(log(colMeans(tNodesA))),max(log(colMeans(tNodesD)))))
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesB),col=2,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesB[1:4]),col=2,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesB[,1:4]),col=2,xlab = 'minimum mesh angle', ylab='mean RMSE')
plot(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesA[,5:8]))),col=1,pch=19,xlab = 'log_10(number of nodes)', ylab='log time',ylim=c(min(log(colMeans(tNodesA))),max(log(colMeans(tNodesD)))))
plot(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesA[,5:8]),col=1,pch=19,xlab = 'log_10(number of nodes)', ylab='log time',ylim=c(min(log(colMeans(tNodesA))),max(log(colMeans(tNodesD)))))
plot(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesA[,5:8]),col=1,pch=19,xlab = 'log_10(number of nodes)', ylab='log time',ylim=c(min(colMeans(rmseNodesA)),max(colMeans(rmseNodesB))))
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesA[,5:8]),col=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesB[5:8])),col=2,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesB[5:8]),col=2,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesB[,5:8]),col=2,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesB[,5:8]),col=2,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesC)),col=3,pch=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(log(tNodesD)),col=4,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 5)[1:4],colMeans(rmseNodesC),col=3,xlab = 'minimum mesh angle', ylab='mean RMSE')
plot(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesA[,5:8]),col=1,pch=19,xlab = 'log_10(number of nodes)', ylab='log time',ylim=c(min(colMeans(rmseNodesA)),max(colMeans(rmseNodesB))))
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesA[,5:8]),col=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesB[,5:8]),col=2,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesB[,5:8]),col=2,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesC),col=3,pch=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesD),col=4,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
grid()
legend('bottomright',legend=c('no preconditioner', 'mass lumping',' lambda preconditioner', 'block preconditioner'), cex=0.62,col=1:4, pch=19)
plot(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesA[,5:8]),col=1,pch=19,xlab = 'log_10(number of nodes)', ylab='RMSE',ylim=c(min(colMeans(rmseNodesA)),max(colMeans(rmseNodesB))))
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesA[,5:8]),col=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesB[,5:8]),col=2,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesB[,5:8]),col=2,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesC),col=3,pch=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseNodesD),col=4,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
grid()
legend('bottomright',legend=c('no preconditioner', 'mass lumping',' lambda preconditioner', 'block preconditioner'), cex=0.62,col=1:4, pch=19)
boxplot(log(tNodesA[,3]),log(tNodesB[,3]),log(tNodesC[,2]),log(tNodesD[,2]), names=c('fdaPDE','mass lumping','lambda','block'),col=c('gray',2,3,4),ylab='log time')
boxplot(log(tNodesA[,3]),log(tNodesB[,2]),log(tNodesC[,2]),log(tNodesD[,2]), names=c('fdaPDE','mass lumping','lambda','block'),col=c('gray',2,3,4),ylab='log time')
boxplot(log(tNodesA[,2]),log(tNodesB[,2]),log(tNodesC[,2]),log(tNodesD[,2]), names=c('fdaPDE','mass lumping','lambda','block'),col=c('gray',2,3,4),ylab='log time')
seq(2.5,4,length.out=4)
seq(2.5,4,length.out=5)
k=2.5
#
# rmseNodesA=NULL
# rmseLocB=NULL
# rmseMeshB=NULL
# j=0
# for(k in seq(2.5,4,length.out = 5))
# {
#   j=j+1
#   set.seed(657489)
#   # varying number of nodes
xit=seq(0,1, length.out = 10^(k/2))
meshit <-create.mesh.2D(expand.grid(xit,xit))
library("fdaPDE", lib.loc="~/R/win-library/4.0")
#
# rmseNodesA=NULL
# rmseLocB=NULL
# rmseMeshB=NULL
# j=0
# for(k in seq(2.5,4,length.out = 5))
# {
#   j=j+1
#   set.seed(657489)
#   # varying number of nodes
xit=seq(0,1, length.out = 10^(k/2))
meshit <-create.mesh.2D(expand.grid(xit,xit))
FEMbasisit = create.FEM.basis(meshit)
seq(2.5,4,length.out=5)
k=2.5
xit=seq(0,1, length.out = 10^(k/2))
meshit <-create.mesh.2D(expand.grid(xit,xit))
plot(mesh)
plot(meshit)
points(locations,col=2,pch=19)
k=2.875
xit=seq(0,1, length.out = 10^(k/2))
meshit <-create.mesh.2D(expand.grid(xit,xit))
plot(meshit)
points(locations,col=2,pch=19)
k=3.25
xit=seq(0,1, length.out = 10^(k/2))
meshit <-create.mesh.2D(expand.grid(xit,xit))
plot(meshit)
points(locations,col=2,pch=19)
k=3.625
xit=seq(0,1, length.out = 10^(k/2))
meshit <-create.mesh.2D(expand.grid(xit,xit))
plot(meshit)
points(locations,col=2,pch=19)
10^seq(2.5,4,length.out = 5)
10^seq(2.5,4,length.out = 4)
load("~/iter.RData")
load("~/data.RData")
load("~/iterationData.RData")
boxplot(tLocD)
load("~/iterationnodes.RData")
bosplot(tLocD)
bosxplot(tLocD)
boxplot(tLocD)
load("~/iter.RData")
load("~/.RData")
boxplot(tLocD)
load("~/iterationnodes.RData")
boxplot(log(tNodesA[,4]),log(tNodesB[,4]),log(tNodesC[,4]),log(tNodesD[,4]), names=c('fdaPDE','mass lumping','lambda','block'),col=c('gray',2,3,4),ylab='log time')
load("~/iterationnodes.RData")
boxplot(log(tLocA[,3]),log(tLocB[,3]),log(tLocC[,2]),log(tLocD[,2]), names=c('fdaPDE','mass lumping','lambda','block'),col=c('gray',2,3,4),ylab='log time')
boxplot(log(tNodesA[,4]),log(tNodesB[,4]),log(tNodesC[,4]),log(tNodesD[,4]), names=c('fdaPDE','mass lumping','lambda','block'),col=c('gray',2,3,4),ylab='log time')
load("~/iterationnodes.RData")
load("~/iterationnodes.RData")
boxplot(log(tLocA[,5]),log(tLocB[,5]),log(tLocC[,4]),log(tLocD[,4]), names=c('fdaPDE','mass lumping','lambda','block'),col=c('gray',2,3,4),ylab='log time')
boxplot(log(tLocA[,5]),log(tLocB[,5]),log(tLocC[,5]),log(tLocD[,4]), names=c('fdaPDE','mass lumping','lambda','block'),col=c('gray',2,3,4),ylab='log time')
boxplot(log(tLocA[,5]),log(tLocB[,5]),log(tLocC[,4]),log(tLocD[,4]), names=c('fdaPDE','mass lumping','lambda','block'),col=c('gray',2,3,4),ylab='log time')
plot(seq(2.5,4,length.out = 5)[1:4],log(colMeans(tLocA)[2:5]),col=1,pch=19,xlab = 'minimum mesh angle', ylab='log time',ylim=c(min(colMeans(log(tLocA))),max(colMeans(log(tLocD))+0.2)))
plot(seq(2.5,4,length.out = 5)[1:4],log(colMeans(tLocA)[2:5]),col=1,pch=19,xlab = 'log_10(number of locations)', ylab='log time',ylim=c(min(colMeans(log(tLocA))),max(colMeans(log(tLocD))+0.2)))
lines(seq(2.5,4,length.out = 5)[1:4],log(colMeans(tLocA)[2:5]),col=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,4,length.out = 5)[1:4],log(colMeans(tLocB)[2:5]),col=2,pch=19,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,4,length.out = 5)[1:4],log(colMeans(tLocB)[2:5]),col=2,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,4,length.out = 5)[1:4],log(colMeans(tLocC)[1:4]),col=3,pch=19,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,4,length.out = 5)[1:4],log(colMeans(tLocC)[1:4]),col=3,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,4,length.out = 5)[1:3],log(colMeans(tLocD)),col=4,pch=19,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,4,length.out = 5)[1:4],log(colMeans(tLocD)),col=4,pch=19,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,4,length.out = 5)[1:4],log(colMeans(tLocD)),col=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
grid()
legend('topright',legend=c('no preconditioner', 'mass lumping',' lambda preconditioner', 'block preconditioner'), cex=0.62,col=1:4, pch=19)
plot(seq(2.5,3.625,length.out = 4),colMeans(rmseLocA),col=1,pch=19,xlab = 'log_10(number of nodes)', ylab='RMSE',ylim=c(min(colMeans(rmseNodesA)),max(colMeans(rmseNodesB))))
plot(seq(2.5,3.625,length.out = 4),colMeans(rmseLocA),col=1,pch=19,xlab = 'log_10(number of nodes)', ylab='RMSE')#,ylim=c(min(colMeans(rmseLocA)),max(colMeans(rmseNodesB))))
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseLocA),col=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseLocB),col=2,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseLocB),col=2,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseLocC),col=3,pch=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 5)[1:4],colMeans(rmseLocC),col=3,xlab = 'minimum mesh angle', ylab='mean RMSE')
plot(seq(2.5,3.625,length.out = 4),colMeans(rmseLocA),col=1,pch=19,xlab = 'log_10(number of nodes)', ylab='RMSE')#,ylim=c(min(colMeans(rmseLocA)),max(colMeans(rmseNodesB))))
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseLocA),col=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseLocB),col=2,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseLocB),col=2,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseLocC),col=3,pch=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseLocC),col=3,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseLocD),col=4,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseLocD),col=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
plot(seq(2.5,3.625,length.out = 4),colMeans(rmseLocA),col=1,pch=19,xlab = 'log_10(number of nodes)', ylab='RMSE')#,ylim=c(min(colMeans(rmseLocA)),max(colMeans(rmseNodesB))))
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseLocA),col=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseLocB),col=2,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseLocB),col=2,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseLocA),col=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseLocC),col=3,pch=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseLocD),col=4,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
grid()
legend('bottomright',legend=c('no preconditioner', 'mass lumping',' lambda preconditioner', 'block preconditioner'), cex=0.62,col=1:4, pch=19)
plot(seq(2.5,3.625,length.out = 4),colMeans(rmseLocA),col=1,pch=19,xlab = 'log_10(number of nodes)', ylab='RMSE')#,ylim=c(min(colMeans(rmseLocA)),max(colMeans(rmseNodesB))))
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseLocA),col=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseLocB),col=2,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseLocB),col=2,xlab = 'minimum mesh angle', ylab='mean RMSE')
lines(seq(2.5,3.625,length.out = 4),colMeans(rmseLocA),col=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseLocC),col=3,pch=1,xlab = 'minimum mesh angle', ylab='mean RMSE')
points(seq(2.5,3.625,length.out = 4),colMeans(rmseLocD),col=4,pch=4,xlab = 'minimum mesh angle', ylab='mean RMSE')
grid()
legend('bottomleft',legend=c('no preconditioner', 'mass lumping',' lambda preconditioner', 'block preconditioner'), cex=0.62,col=1:4, pch=19)
load("~/simulrmse/glm.RData")
dim(mesh$nodes)
dim(mesh1$nodes)
plot(mesh)
plot(mesh1)
library("fdaPDE", lib.loc="~/R/win-library/4.0")
plot(mesh1)
points(loc, col=2, pch=19)
dim(mesh1$nodes)[1]
800*800
dim(loc)
plot(log10(lambda), colMeans(rmse1A), pch=4, col=1, ylab="Mean RMSE")
lines(log10(lambda), colMeans(rmse1A), pch=4, col=1)
points(log10(lambda), colMeans(rmse1B), pch=4, col=2)
lines(log10(lambda), colMeans(rmse1B), col=2)
points(log10(lambda), colMeans(rmse1C), pch=1, col=3)
points(log10(lambda), colMeans(rmse1D), pch=6, col=4)
boxplot(rmseA[,which.min(colMeans(rmseA))],rmseB[,which.min(colMeans(rmseB))],
rmseC[,which.min(colMeans(rmseC))],rmseD[,which.min(colMeans(rmseD))],
names=c("fdaPDE", "Mass lumping", "Lambda", "Block"),
col=c("grey", 2,3,4))
plot(log10(lambda), colMeans(rmse4A), pch=4, col=1, ylab="Mean RMSE")
lines(log10(lambda), colMeans(rmse4A), pch=4, col=1)
points(log10(lambda), colMeans(rmse4B), pch=4, col=2)
lines(log10(lambda), colMeans(rmse4B), col=2)
points(log10(lambda), colMeans(rmse4C), pch=1, col=3)
points(log10(lambda), colMeans(rmse4D), pch=6, col=4)
load("~/glm.RData")
boxplot(rmse1A,rmse1B,rmse1C,rmse1D, names=c('fdaPDE', 'mass lumping', 'lambda','block'), col=c('grey', 2,3,4),ylab='RMSE')
boxplot(rmse1A,rmse1B,rmse1C,rmse1D, names=c('fdaPDE', 'mass lumping', 'lambda','block'), col=c('grey', 2,3,4),ylab='RMSE')
boxplot(rmse1A,rmse1B,rmse1C, names=c('fdaPDE', 'mass lumping', 'lambda'), col=c('grey', 2,3),ylab='RMSE')
boxplot(rmse2A,rmse2B,rmse2C, names=c('fdaPDE', 'mass lumping', 'lambda'), col=c('grey', 2,3),ylab='RMSE')
load("~/glm.RData")
load("~/glm 1.RData")
boxplot(rmse2A,rmse2B,rmse2C, names=c('fdaPDE', 'mass lumping', 'lambda'), col=c('grey', 2,3),ylab='RMSE')
boxplot(rmse2A,rmse2B,rmse2C), names=c('fdaPDE', 'mass lumping', 'lambda'), col=c('grey', 2,3),ylab='RMSE')
boxplot(rmse2A,rmse2B,rmse2C)#, names=c('fdaPDE', 'mass lumping', 'lambda'), col=c('grey', 2,3),ylab='RMSE')
boxplot(rmse1A)
load("~/glm.RData")
load("~/simulrmse/glm.RData")
load("~/glm 1.RData")
plot(log10(lambda), colMeans(rmse4A), pch=4, col=1, ylab="Mean RMSE")
lines(log10(lambda), colMeans(rmse4A), pch=4, col=1)
points(log10(lambda), colMeans(rmse4B), pch=4, col=2)
lines(log10(lambda), colMeans(rmse4B), col=2)
points(log10(lambda), colMeans(rmse4C), pch=1, col=3)
points(log10(lambda), colMeans(rmse4D), pch=6, col=4)
grid()
legend('bottomleft',legend=c('no preconditioner', 'mass lumping',' lambda preconditioner', 'block preconditioner'), cex=0.62,col=1:4, pch=19)
plot(log10(lambda), colMeans(rmse4A), pch=4, col=1, ylab="Mean RMSE")
lines(log10(lambda), colMeans(rmse4A), pch=4, col=1)
points(log10(lambda), colMeans(rmse4B), pch=4, col=2)
lines(log10(lambda), colMeans(rmse4B), col=2)
points(log10(lambda), colMeans(rmse4C), pch=1, col=3)
points(log10(lambda), colMeans(rmse4D), pch=6, col=4)
grid()
legend('topright',legend=c('no preconditioner', 'mass lumping',' lambda preconditioner', 'block preconditioner'), cex=0.62,col=1:4, pch=19)
plot(log10(lambda), colMeans(rmse4A), pch=4, col=1, ylab="Mean RMSE", ylim=c(min(colMeans(rmse4A)),max(colMeans(rmse4B))))
lines(log10(lambda), colMeans(rmse4A), pch=4, col=1)
points(log10(lambda), colMeans(rmse4B), pch=4, col=2)
lines(log10(lambda), colMeans(rmse4B), col=2)
points(log10(lambda), colMeans(rmse4C), pch=1, col=3)
points(log10(lambda), colMeans(rmse4D), pch=6, col=4)
grid()
legend('topright',legend=c('no preconditioner', 'mass lumping',' lambda preconditioner', 'block preconditioner'), cex=0.62,col=1:4, pch=19)
boxplot(rmse4A[,which.min(colMeans(rmse4A))],rmse4B[,which.min(colMeans(rmse4B))],
rmse4C[,which.min(colMeans(rms4eC))],rmse4D[,which.min(colMeans(rmse4D))],
names=c("fdaPDE", "Mass lumping", "Lambda", "Block"),
col=c("grey", 2,3,4))
boxplot(rmse4A[,which.min(colMeans(rmse4A))],rmse4B[,which.min(colMeans(rmse4B))],
rmse4C[,which.min(colMeans(rmse4C))],rmse4D[,which.min(colMeans(rmse4D))],
names=c("fdaPDE", "Mass lumping", "Lambda", "Block"),
col=c("grey", 2,3,4))
load("~/glm.RData")
boxplot(log(t1A$time),log(t1B$time),log(t1C$time), names=c('fdaPDE','mass lumping','lambda'),col=c('grey',2,3), ylab='log(time)')
boxplot(log(t1A$time),log(t1B$time),log(t1C$time),log(t1D$time), names=c('fdaPDE','mass lumping','lambda','block'),col=c('grey',2,3,4), ylab='log(time)')
boxplot(log(t2A$time),log(t2B$time),log(t2C$time), log(t2D$time), names=c('fdaPDE','mass lumping','lambda','block'),col=c('grey',2,3,4), ylab='log(time)')
boxplot(log(t3A$time),log(t3B$time),log(t3C$time),log(t3D$time), names=c('fdaPDE','mass lumping','lambda','block'),col=c('grey',2,344), ylab='log(time)')
boxplot(log(t4A$time),log(t4B$time),log(t4C$time),log(t4D$time), names=c('fdaPDE','mass lumping','lambda','block'),col=c('grey',2,3,4), ylab='log(time)')
boxplot(log(t1A$time),log(t1B$time),log(t1C$time),log(t1D$time), names=c('fdaPDE','mass lumping','lambda','block'),col=c('grey',2,3,4), ylab='log(time)')
boxplot(log(t2A$time),log(t2B$time),log(t2C$time), log(t2D$time), names=c('fdaPDE','mass lumping','lambda','block'),col=c('grey',2,3,4), ylab='log(time)')
boxplot(log(t3A$time),log(t3B$time),log(t3C$time),log(t3D$time), names=c('fdaPDE','mass lumping','lambda','block'),col=c('grey',2,3,4), ylab='log(time)')
boxplot(log(t4A$time),log(t4B$time),log(t4C$time),log(t4D$time), names=c('fdaPDE','mass lumping','lambda','block'),col=c('grey',2,3,4), ylab='log(time)')
inv.link
# Set smoothing parameter
lambda = 10^seq(-5,0,length.out = 20)
# 2D random field (function f)
a1=-2.5
z<-function(p)
{
a1*sin(2*pi*p[1])*cos(2*pi*p[2])+a2*sin(3*pi*p[1])
}
a2=0.8
rmse1B<-NULL
for(l in lambda)
{
set.seed(1527)
#best_lambda <- NULL
rmse <- NULL
for (i in 1:30)
{
output_CPP<-smooth.FEM(locations = loc, observations = as.numeric(response1 <- rbernoulli(length(loc[,1]),p = mu1)),
FEMbasis =FEMbasis, covariates = NULL,
max.steps=15, family =FAMILY1, mu0=NULL, scale.param=NULL,
lambda = l)
# best_lambda<-c(best_lambda,
#               which(output_CPP$optimization$GCV_vector==min(output_CPP$optimization$GCV_vector)))
# output_CPP<-smooth.FEM(observations=data3d+rnorm (length(nodes3d[1,]), sd=0.01*(ran3d[2]-ran3d[1])),
#                        FEMbasis=FEMbasis, #locations=locations,
#                        lambda=lambda[best_lambda[i]])
rmse <- c(rmse, RMSE(z(loc_eval),eval.FEM(output_CPP$fit.FEM,locations=loc_eval)))
}
rmse1B<-cbind(rmse1B, rmse)
}
library("fdaPDE", lib.loc="~/R/win-library/4.0")
rmse1B<-NULL
for(l in lambda)
{
set.seed(1527)
#best_lambda <- NULL
rmse <- NULL
for (i in 1:30)
{
output_CPP<-smooth.FEM(locations = loc, observations = as.numeric(response1 <- rbernoulli(length(loc[,1]),p = mu1)),
FEMbasis =FEMbasis, covariates = NULL,
max.steps=15, family =FAMILY1, mu0=NULL, scale.param=NULL,
lambda = l)
# best_lambda<-c(best_lambda,
#               which(output_CPP$optimization$GCV_vector==min(output_CPP$optimization$GCV_vector)))
# output_CPP<-smooth.FEM(observations=data3d+rnorm (length(nodes3d[1,]), sd=0.01*(ran3d[2]-ran3d[1])),
#                        FEMbasis=FEMbasis, #locations=locations,
#                        lambda=lambda[best_lambda[i]])
rmse <- c(rmse, RMSE(z(loc_eval),eval.FEM(output_CPP$fit.FEM,locations=loc_eval)))
}
rmse1B<-cbind(rmse1B, rmse)
}
library(purrrr)
library(purrr)
for(l in lambda)
{
set.seed(1527)
#best_lambda <- NULL
rmse <- NULL
for (i in 1:30)
{
output_CPP<-smooth.FEM(locations = loc, observations = as.numeric(response1 <- rbernoulli(length(loc[,1]),p = mu1)),
FEMbasis =FEMbasis, covariates = NULL,
max.steps=15, family =FAMILY1, mu0=NULL, scale.param=NULL,
lambda = l)
# best_lambda<-c(best_lambda,
#               which(output_CPP$optimization$GCV_vector==min(output_CPP$optimization$GCV_vector)))
# output_CPP<-smooth.FEM(observations=data3d+rnorm (length(nodes3d[1,]), sd=0.01*(ran3d[2]-ran3d[1])),
#                        FEMbasis=FEMbasis, #locations=locations,
#                        lambda=lambda[best_lambda[i]])
rmse <- c(rmse, RMSE(z(loc_eval),eval.FEM(output_CPP$fit.FEM,locations=loc_eval)))
}
rmse1B<-cbind(rmse1B, rmse)
}
plot(log10(lambda), colMeans(rmse1A), pch=4, col=1, ylab="Mean RMSE", ylim=c(min(colMeans(rmse4A)),max(colMeans(rmse4B))))
lines(log10(lambda), colMeans(rmse1A), pch=4, col=1)
plot(log10(lambda), colMeans(rmse1A), pch=4, col=1, ylab="Mean RMSE")#, ylim=c(min(colMeans(rmse4A)),max(colMeans(rmse4B))))
lines(log10(lambda), colMeans(rmse1A), pch=4, col=1)
points(log10(lambda), colMeans(rmse1B), pch=4, col=2)
lines(log10(lambda), colMeans(rmse1B), col=2)
points(log10(lambda), colMeans(rmse1C), pch=1, col=3)
points(log10(lambda), colMeans(rmse1D), pch=6, col=4)
grid()
legend('topright',legend=c('no preconditioner', 'mass lumping',' lambda preconditioner', 'block preconditioner'), cex=0.62,col=1:4, pch=19)
boxplot(rmse1A[,which.min(colMeans(rmse1A))],rmse1B[,which.min(colMeans(rmse1B))],
rmse1C[,which.min(colMeans(rmse1C))],rmse1D[,which.min(colMeans(rmse1D))],
names=c("fdaPDE", "Mass lumping", "Lambda", "Block"),
col=c("grey", 2,3,4))
load("~/squareCov.RData")
plot(log10(lambda), res5, pch=4, xlab='log_10(lambda)', ylab='residual', col=1)#, ylim=c(0,0.026))
grid()
abline(v=log10(best_lambda5[1]), lty=2, col='red')
lines(-12:3, res5, col=1)
points(log10(best_lambda5[1]), res5[13], pch=19, col='red')
load("~/simulrmse/hs.RData")
plot(log10(lambda), colMeans(rmseCovA), pch=4, col=1, ylab="Mean RMSE", ylim=c(min(colMeans(rmseCovA)),max(colMeans(rmseCovB))))
lines(log10(lambda), colMeans(rmseCovA), pch=4, col=1)
points(log10(lambda), colMeans(rmseCovB), pch=4, col=2)
lines(log10(lambda), colMeans(rmseCovB), col=2)
points(log10(lambda), colMeans(rmseCovC), pch=1, col=3)
points(log10(lambda), colMeans(rmseCovD), pch=6, col=4)
points(log10(lambda), colMeans(rmseCovC), pch=1, col=3)
load("~/sphere.RData")
load("~/simulrmse/hs.RData")
rmseCovC=NULL
for(l in lambda)
{
set.seed(1527)
#best_lambda <- NULL
rmse <- NULL
for (i in 1:30)
{
output_CPP<-smooth.FEM(observations=dataCov+rnorm (length(nodes[1,]), sd=0.01*(ranCov[2]-ranCov[1])),
FEMbasis=FEMbasis, covariates=cov,#locations=locations,
lambda=l)
# best_lambda<-c(best_lambda,
#               which(output_CPP$optimization$GCV_vector==min(output_CPP$optimization$GCV_vector)))
# output_CPP<-smooth.FEM(observations=data3d+rnorm (length(nodes3d[1,]), sd=0.01*(ran3d[2]-ran3d[1])),
#                        FEMbasis=FEMbasis, #locations=locations,
#                        lambda=lambda[best_lambda[i]])
rmse <- c(rmse, RMSE(fs.test( loc_eval[,1],loc_eval[,2]),eval.FEM(output_CPP$fit.FEM,locations=loc_eval)))
}
rmseCovC<-cbind(rmseCovC, rmse)
}
library("fdaPDE", lib.loc="~/R/win-library/4.0")
rmseCovC=NULL
for(l in lambda)
{
set.seed(1527)
#best_lambda <- NULL
rmse <- NULL
for (i in 1:30)
{
output_CPP<-smooth.FEM(observations=dataCov+rnorm (length(nodes[1,]), sd=0.01*(ranCov[2]-ranCov[1])),
FEMbasis=FEMbasis, covariates=cov,#locations=locations,
lambda=l)
# best_lambda<-c(best_lambda,
#               which(output_CPP$optimization$GCV_vector==min(output_CPP$optimization$GCV_vector)))
# output_CPP<-smooth.FEM(observations=data3d+rnorm (length(nodes3d[1,]), sd=0.01*(ran3d[2]-ran3d[1])),
#                        FEMbasis=FEMbasis, #locations=locations,
#                        lambda=lambda[best_lambda[i]])
rmse <- c(rmse, RMSE(fs.test( loc_eval[,1],loc_eval[,2]),eval.FEM(output_CPP$fit.FEM,locations=loc_eval)))
}
rmseCovC<-cbind(rmseCovC, rmse)
}
save.image("~/simulrmse/hs.RData")
plot(log10(lambdaGLM), colMeans(rmseGLMA), pch=4, col=1, ylab="Mean RMSE")
plot(log10(lambda), colMeans(rmseCovA), pch=4, col=1, ylab="Mean RMSE", ylim=c(min(colMeans(rmseCovA)),max(colMeans(rmseCovB))))
lines(log10(lambda), colMeans(rmseCovA), pch=4, col=1)
points(log10(lambda), colMeans(rmseCovB), pch=4, col=2)
lines(log10(lambda), colMeans(rmseCovB), col=2)
points(log10(lambda), colMeans(rmseCovC), pch=1, col=3)
points(log10(lambda), colMeans(rmseCovD), pch=6, col=4)
grid()
legend('bottomleft',legend=c('no preconditioner', 'mass lumping',' lambda preconditioner', 'block preconditioner'), cex=0.62,col=1:4, pch=19)
load("~/time.RData")
load("~/sphere.RData")
tcovC=microbenchmark(smooth.FEM(observations = dataCov, covariates = W, FEMbasis = FEMbasis, lambda=best_lambdaCov1[1]),times=30)
library("microbenchmark", lib.loc="~/R/win-library/4.0")
tcovC=microbenchmark(smooth.FEM(observations = dataCov, covariates = W, FEMbasis = FEMbasis, lambda=best_lambdaCov1[1]),times=30)
boxplot(log(tcovE$time),log(tcovF$time),log(tcovC$time),log(tcovH$time), names=c('fdaPDE','mass lumping','lambda','block'),col=c('grey',2,3,4), ylab='log(time)')
load("~/sphere.RData")
boxplot(log(tcovE$time),log(tcovF$time),log(tcovC$time),log(tcovH$time), names=c('fdaPDE','mass lumping','lambda','block'),col=c('grey',2,3,4), ylab='log(time)')
tcovC=microbenchmark(smooth.FEM(observations = dataCov, covariates = W, FEMbasis = FEMbasis, lambda=best_lambdaCov1[1]),times=30)
library("fdaPDE", lib.loc="~/R/win-library/4.0")
library("microbenchmark", lib.loc="~/R/win-library/4.0")
tcovC=microbenchmark(smooth.FEM(observations = dataCov, covariates = W, FEMbasis = FEMbasis, lambda=best_lambdaCov1[1]),times=30)
boxplot(log(tcovE$time),log(tcovF$time),log(tcovC$time),log(tcovH$time), names=c('fdaPDE','mass lumping','lambda','block'),col=c('grey',2,3,4), ylab='log(time)')
install.packages("geometry")
install.packages("plot3D")
install.packages("plot3Drgl")
install.packages("RcppEigen")
.libPaths()
install.packages("RcppEigen", lib.loc="C:/Program Files/R/R-4.0.4/library")
install.packages("RcppEigen", lib="C:/Program Files/R/R-4.0.4/library")
.libPaths(c(libPaths, C:\Users\beacr\AppData\Local\Temp\RtmpMVY0to\downloaded_packages))
.libPaths(c(libPaths, "C:\Users\beacr\AppData\Local\Temp\RtmpMVY0to\downloaded_packages"))
.libPaths(c(libPaths, "C:/Users/beacr/AppData/Local/Temp/RtmpMVY0to/downloaded_packages"))
.libPaths(c(.libPaths(), "C:/Users/beacr/AppData/Local/Temp/RtmpMVY0to/downloaded_packages"))
.libPaths()
library("geometry", lib.loc="~/R/win-library/4.0")
library("fdaPDE", lib.loc="~/R/win-library/4.0")
install.packages("shiny")
install.packages("Matrix")
devtools::install_deps(dependencies = TRUE)
install_deps(dependencies = TRUE)
install.packages("devtools")
library("devtools", lib.loc="~/R/win-library/4.0")
devtools::install_deps(dependencies = TRUE)
setwd("C:/Users/beacr/Downloads/fdaPDE-main")
devtools::install_deps(dependencies = TRUE)
check(force_suggests = FALSE)
devtools::document(setwd("C:/Users/beacr/Downloads/fdaPDE-main"))
setwd("C:/Users/beacr/Downloads/fdaPDE-main")
check(force_suggests = FALSE)
setwd("C:/Users/beacr/Downloads/fdaPDE-main/fdaPDE")
check(force_suggests = FALSE)
devtools::install_deps(dependencies = TRUE)
